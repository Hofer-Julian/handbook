"use strict";(self.webpackChunkhandbook=self.webpackChunkhandbook||[]).push([[6926],{4137:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>p});var i=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},l=Object.keys(e);for(i=0;i<l.length;i++)t=l[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(i=0;i<l.length;i++)t=l[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=i.createContext({}),d=function(e){var n=i.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},c=function(e){var n=d(e.components);return i.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},m=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,l=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),m=d(t),p=a,h=m["".concat(s,".").concat(p)]||m[p]||u[p]||l;return t?i.createElement(h,r(r({ref:n},c),{},{components:t})):i.createElement(h,r({ref:n},c))}));function p(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var l=t.length,r=new Array(l);r[0]=m;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o.mdxType="string"==typeof e?e:a,r[1]=o;for(var d=2;d<l;d++)r[d]=t[d];return i.createElement.apply(null,r)}return i.createElement.apply(null,t)}m.displayName="MDXCreateElement"},7447:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>l,metadata:()=>o,toc:()=>d});var i=t(7462),a=(t(7294),t(4137));const l={id:"queries",title:"Queries"},r=void 0,o={unversionedId:"specification/APIs/queries",id:"specification/APIs/queries",title:"Queries",description:"- The GraphQL schema of a node changes depending on the schemas that are available on the node.",source:"@site/docs/specification/APIs/queries.md",sourceDirName:"specification/APIs",slug:"/specification/APIs/queries",permalink:"/specification/APIs/queries",draft:!1,tags:[],version:"current",frontMatter:{id:"queries",title:"Queries"},sidebar:"specification",previous:{title:"Publishing",permalink:"/specification/APIs/publishing"},next:{title:"Blob HTTP service",permalink:"/specification/APIs/blob-http"}},s={},d=[{value:"<code>&lt;schema_id&gt;</code>",id:"schema_id",level:2},{value:"<code>all_&lt;schema_id&gt;</code>",id:"all_schema_id",level:2},{value:"types",id:"types",level:2},{value:"Scalars",id:"scalars",level:3},{value:"Responses",id:"responses",level:3},{value:"Filters",id:"filters",level:3},{value:"Ordering",id:"ordering",level:3}],c={toc:d};function u(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,i.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The GraphQL schema of a node changes depending on the schemas that are available on the node."),(0,a.kt)("li",{parentName:"ul"},"A node inserts additional queryable fields into the root query type for every schema that can be queried.",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"In addition, corresponding types for responses, pagination, ordering and filtering are generated according to the schemas' definitions."),(0,a.kt)("li",{parentName:"ul"},"Together, these allow clients to request documents including their materialized views and metadata."),(0,a.kt)("li",{parentName:"ul"},"Detailed descriptions of the generated types and queries follows below."))),(0,a.kt)("li",{parentName:"ul"},"Therefore, client implementations SHOULD gracefully handle being connected to a node that doesn't process a schema they would like to interact with."),(0,a.kt)("li",{parentName:"ul"},"This specification defines a generic form for these dynamic GraphQL fields and types.",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"The string ",(0,a.kt)("inlineCode",{parentName:"li"},"<schema_id>")," is used as a generic placeholder to be replaced by a concrete ",(0,a.kt)("em",{parentName:"li"},"schema id"),".")))),(0,a.kt)("h2",{id:"schema_id"},(0,a.kt)("inlineCode",{parentName:"h2"},"<schema_id>")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Returns a single document that uses this schema",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Implementations must have no side effects"))),(0,a.kt)("li",{parentName:"ul"},"The name of this field is equal to the ",(0,a.kt)("em",{parentName:"li"},"schema id")," of the schema it represents"),(0,a.kt)("li",{parentName:"ul"},"Either the ",(0,a.kt)("inlineCode",{parentName:"li"},"id")," or ",(0,a.kt)("inlineCode",{parentName:"li"},"viewId")," field argument must be set",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"If ",(0,a.kt)("inlineCode",{parentName:"li"},"id")," contains a document id, the response must contain the ",(0,a.kt)("a",{parentName:"li",href:"/specification/data-types/documents#the-latest-document-view"},(0,a.kt)("em",{parentName:"a"},"latest document view"))," for that document"),(0,a.kt)("li",{parentName:"ul"},"If ",(0,a.kt)("inlineCode",{parentName:"li"},"viewId")," contains a document view id, the response must contain this document view"),(0,a.kt)("li",{parentName:"ul"},"If both field arguments are given the view id is used"))),(0,a.kt)("li",{parentName:"ul"},'Not every node holds all documents and especially not all document views (historical states of a document) in its database because of the decentralised nature of p2panda. in this case a "not found" error will be returned')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-graphql"},"type QueryRoot {\n  # ... other query root fields here ...\n\n  <schema_id>(\n    # id of the document to be queried\n    id: DocumentId\n\n    # specific document view id to be queried\n    viewId: DocumentViewId\n  ): <schema_id>\n}\n")),(0,a.kt)("h2",{id:"all_schema_id"},(0,a.kt)("inlineCode",{parentName:"h2"},"all_<schema_id>")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Returns the ",(0,a.kt)("a",{parentName:"li",href:"/specification/data-types/documents#the-latest-document-view"},"latest document view")," for many documents of a given schema",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Implementations must have no side effects"))),(0,a.kt)("li",{parentName:"ul"},"Deleted documents must not be included in the response unless they are explicitly included using a filter"),(0,a.kt)("li",{parentName:"ul"},"Response is paginated, can be sorted and filtered")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-graphql"},"type QueryRoot {\n  # ... other query root fields here ...\n\n  # Get all <schema_id> documents with pagination, ordering and filtering.\n  all_<schema_id>(\n    # Filter the query based on field values\n    filter: <schema_id>Filter\n\n    # Filter the query based on meta field values\n    meta: MetaFilterInput\n\n    # Field by which items in the collection will be ordered\n    orderBy: <schema_id>OrderBy\n\n    # Direction which items in the collection will be ordered\n    orderDirection: OrderDirection\n\n    # Number of paginated items we want from this request\n    first: Int = 25\n\n    # The item we wish to start paginating from identified by a cursor\n    after: Cursor\n  ): <schema_id>Collection!\n}\n")),(0,a.kt)("h2",{id:"types"},"types"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"A node's GraphQL schema contains both statically defined and dynamically created types."),(0,a.kt)("li",{parentName:"ul"},"these types may relate to query arguments for handling filtering, ordering and pagination or types present on query responses."),(0,a.kt)("li",{parentName:"ul"},"dynamically created types always contain the ",(0,a.kt)("inlineCode",{parentName:"li"},"schema_id")," of the schema they are derived from in their name, whereas static types do not."),(0,a.kt)("li",{parentName:"ul"},"for simple values scalar types are used:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Document fields with the types ",(0,a.kt)("inlineCode",{parentName:"li"},"Boolean"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"Integer"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"Float")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"String")," are represented with the corresponding GraphQL scalar types."),(0,a.kt)("li",{parentName:"ul"},"Document fields with the relation types ",(0,a.kt)("inlineCode",{parentName:"li"},"Relation")," / ",(0,a.kt)("inlineCode",{parentName:"li"},"RelationList")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"PinnedRelation")," / ",(0,a.kt)("inlineCode",{parentName:"li"},"PinnedRelationList")," use the type generated for that field's schema."))),(0,a.kt)("li",{parentName:"ul"},"the following is a list of all other generated and static types which can be found in a node's root GraphQL schema.")),(0,a.kt)("h3",{id:"scalars"},"Scalars"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-graphql"},"# cursor used in paginated queries.\nscalar Cursor\n\n# id of a p2panda document.\nscalar DocumentId\n\n# document view id of a p2panda document. Refers to a specific point in a documents history\n# and can be used to deterministically reconstruct it's state at that time.\nscalar DocumentViewId\n\n# signed bamboo entry, encoded as a hexadecimal string.\nscalar EncodedEntry\n\n# entry payload and p2panda operation, CBOR bytes encoded as a hexadecimal string.\nscalar EncodedOperation\n\n# hash of a signed bamboo entry.\nscalar EntryHash\n\n# log id of a bamboo entry.\nscalar LogId\n\n# public key that signed the entry.\nscalar PublicKey\n\n# sequence number of an entry.\nscalar SeqNum\n\n")),(0,a.kt)("h3",{id:"responses"},"Responses"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-graphql"},"# response from a request for a single <schema_id> document\ntype <schema_id> {\n  # application fields of a `<schema_id>` document.\n  fields: <schema_id>Fields\n\n  # meta fields of a `<schema_id>` document.\n  meta: DocumentMeta\n}\n\n# application fields of a `<schema_id>` document.\ntype <schema_id>Fields {\n  # named fields containing the actual, materialized values of this document view. the form is defined by the regarding p2panda schema\n  <field_name>: <field_type>\n\n  # ... potentially more fields\n}\n\n# single page response returned when querying a collection of `<schema_id>` documents.\ntype <schema_id>Collection {\n  # total number of documents available in this paginated collection.\n  totalCount: Int!\n\n  # cursor for the next page\n  endCursor: String!\n\n  # boolean value denoting whether there is a next page available on this query.\n  hasNextPage: Boolean!\n\n  # field containing the actual document fields.\n  documents: [<schema_id>Item!]!\n}\n\n# single item in a paginated collection response\ntype <schema_id>Item {\n  # application fields of a `band` document.\n  fields: <schema_id>Fields\n\n  # meta fields of a `band` document.\n  meta: DocumentMeta\n\n  # the pagination `cursor` for this `<schema_id>` document.\n  cursor: String\n}\n\n# Meta fields of a document, contains id and authorship information.\ntype DocumentMeta {\n  # document id of this document.\n  documentId: DocumentId!\n\n  # document view id of this document.\n  viewId: DocumentViewId!\n\n  # public key of the author who first created this document.\n  owner: PublicKey!\n}\n\n")),(0,a.kt)("h3",{id:"filters"},"Filters"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-graphql"},"\n# A filter input type for boolean field values.\ninput BooleanFilter {\n  # Filter by equal to.\n  eq: Boolean\n\n  # Filter by not equal to.\n  notEq: Boolean\n}\n\n# A filter input type for integer field values.\ninput FloatFilter {\n  # Filter by values in set.\n  in: [Integer!]\n\n  # Filter by values not in set.\n  notIn: [Integer!]\n\n  # Filter by equal to.\n  eq: Integer\n\n  # Filter by not equal to.\n  notEq: Integer\n\n  # Filter by greater than or equal to.\n  gte: Integer\n\n  # Filter by greater than.\n  gt: Integer\n\n  # Filter by less than or equal to.\n  lte: Integer\n\n  # Filter by less than.\n  lt: Integer\n}\n\n# A filter input type for float field values.\ninput FloatFilter {\n  # Filter by values in set.\n  in: [Float!]\n\n  # Filter by values not in set.\n  notIn: [Float!]\n\n  # Filter by equal to.\n  eq: Float\n\n  # Filter by not equal to.\n  notEq: Float\n\n  # Filter by greater than or equal to.\n  gte: Float\n\n  # Filter by greater than.\n  gt: Float\n\n  # Filter by less than or equal to.\n  lte: Float\n\n  # Filter by less than.\n  lt: Float\n}\n\n# A filter input type for string field values.\ninput StringFilter {\n  # Filter by values in set.\n  in: [String!]\n\n  # Filter by values not in set.\n  notIn: [String!]\n\n  # Filter by equal to.\n  eq: String\n\n  # Filter by not equal to.\n  notEq: String\n\n  # Filter by greater than or equal to.\n  gte: String\n\n  # Filter by greater than.\n  gt: String\n\n  # Filter by less than or equal to.\n  lte: String\n\n  # Filter by less than.\n  lt: String\n\n  # Filter for items which contain given value.\n  contains: String\n\n  # Filter for items which don't contain given value.\n  notContains: String\n}\n\n\n# A filter input type for relation field values.\ninput RelationFilter {\n  # Filter by equal to.\n  eq: DocumentId\n\n  # Filter by not equal to.\n  notEq: DocumentId\n\n  # Filter by values in set.\n  in: [DocumentId!]\n\n  # Filter by values not in set.\n  notIn: [DocumentId!]\n}\n\n# A filter input type for relation list field values.\ninput RelationListFilter {\n  # Filter by values in set.\n  in: [DocumentId!]\n\n  # Filter by values not in set.\n  notIn: [DocumentId!]\n}\n\n# A filter input type for pinned relation field values.\ninput PinnedRelationFilter {\n  # Filter by equal to.\n  eq: DocumentViewId\n\n  # Filter by not equal to.\n  notEq: DocumentViewId\n\n  # Filter by values in set.\n  in: [DocumentViewId!]\n\n  # Filter by values not in set.\n  notIn: [DocumentViewId!]\n}\n\n# A filter input type for pinned relation list field values.\ninput PinnedRelationListFilter {\n  # Filter by values in set.\n  in: [DocumentViewId!]\n\n  # Filter by values not in set.\n  notIn: [DocumentViewId!]\n}\n\n# A filter input type for document id field on meta object.\ninput DocumentIdFilter {\n  # Filter by values in set.\n  in: [DocumentId!]\n\n  # Filter by values not in set.\n  notIn: [DocumentId!]\n\n  # Filter by equal to.\n  eq: DocumentId\n\n  # Filter by not equal to.\n  notEq: DocumentId\n}\n\n# A filter input type for document view id field on meta object.\ninput DocumentViewIdFilter {\n  # Filter by values in set.\n  in: [DocumentViewId!]\n\n  # Filter by values not in set.\n  notIn: [DocumentViewId!]\n\n  # Filter by equal to.\n  eq: DocumentViewId\n\n  # Filter by not equal to.\n  notEq: DocumentViewId\n}\n\n# A filter input type for owner field on meta object.\ninput OwnerFilter {\n  # Filter by values in set.\n  in: [PublicKey!]\n\n  # Filter by values not in set.\n  notIn: [PublicKey!]\n\n  # Filter by equal to.\n  eq: PublicKey\n\n  # Filter by not equal to.\n  notEq: PublicKey\n}\n\n# Filter input containing all meta fields a collection of documents can be filtered by. Is\n# passed to the `meta` argument on a document collection query or list relation fields.\ninput MetaFilterInput {\n  # Document id filter.\n  documentId: DocumentIdFilter\n\n  # Document view id filter.\n  viewId: DocumentViewIdFilter\n\n  # Owner filter.\n  owner: OwnerFilter\n\n  # Edited filter.\n  edited: BooleanFilter\n\n  # Deleted filter.\n  deleted: BooleanFilter\n}\n\n# Filters for a documents' application fields\ninput <schema_id>Filter {\n  # field to filter by\n  <field_name>: BooleanFilter | IntegerFilter | FloatFilter | StringFilter | RelationFilter | RelationListFilter | PinnedRelationFilter | PinnedRelationListFilter\n\n  # ... potentially more fields\n}\n\n")),(0,a.kt)("h3",{id:"ordering"},"Ordering"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-graphql"},"\n# Possible ordering direction for collection queries.\nenum OrderDirection {\n  ASC\n  DESC\n}\n\nenum <schema_id>OrderBy {\n  DOCUMENT_ID\n  DOCUMENT_VIEW_ID\n  <field_name>\n  # ... potentially more fields\n}\n\n")))}u.isMDXComponent=!0}}]);