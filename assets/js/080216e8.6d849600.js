(self.webpackChunkhandbook=self.webpackChunkhandbook||[]).push([[6705],{5244:(e,t,n)=>{e.exports={src:{srcSet:n.p+"assets/ideal-img/mushroom-app.fdf2308.808.png 808w",images:[{path:n.p+"assets/ideal-img/mushroom-app.fdf2308.808.png",width:808,height:1e3}],src:n.p+"assets/ideal-img/mushroom-app.fdf2308.808.png",toString:function(){return n.p+"assets/ideal-img/mushroom-app.fdf2308.808.png"},placeholder:void 0,width:808,height:1e3},preSrc:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAMCAIAAADUCbv3AAAACXBIWXMAAAsTAAALEwEAmpwYAAABaElEQVQYlT2Ov0sCYQBA709obgwamhqCgghaWxIrUiGEknBsaKi2BqGgIYIabKwhGsIKKRDLIIVCSAjFNKW4O+/OO7/v7vt5l+dp0Q+aH+/xhEKrpdhYZEjk6KlWeX14lDCUbCxzVCOmUNS1pqnJUJWBWpfk6rsoGkoDqA2gSJYhlE2AXQrbGDpUMizZgMAhZptYbaLZWHixIOlQ1GEagblCMV+q6ByjDkMubTpYKFuQdW2NgMP43vFRPBicX46EoYOwx77tsgl4z1aRvh3bqD6nz08OFgI+ESjs0/nBFqAeN9s4FPBtrkdvL/ZXVyJvuvyPIfUYclkkvDQyPBr0+0KzcyoCpMv/1qjH4Acp1e4zN4l89vounTSohT3W/I1jj6EO2YnN7EYHUltjoamhBtJJ11ZtLFQsyLs2cumifyI83rc23e+fHGwxwHqO7hChYBgqxxJFmWzu7PLqNJFM3WZEYjY4rmPzCx4VIzF26HBJAAAAAElFTkSuQmCC"}},2233:(e,t,n)=>{"use strict";n.d(t,{Z:()=>l});var a=n(7294),i=n(5944);const o="image-frame_fg61",r="image-frame-inner_Xabn",s="image-frame-title_UNlE";function l(e){let{title:t,url:n}=e;return n?a.createElement("div",{className:o},a.createElement("div",{className:r},a.createElement(i.Z,{alt:t,title:t,img:n})),t&&a.createElement("div",{className:s},t)):null}},7940:(e,t,n)=>{"use strict";n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>m});var a=n(7462),i=(n(7294),n(4137)),o=n(2233);const r={title:"Tutorial: Let's build a mushroom app!"},s=void 0,l={unversionedId:"tutorials/mushroom-app",id:"tutorials/mushroom-app",title:"Tutorial: Let's build a mushroom app!",description:"In this tutorial we will build an web app for finding and identifying mushrooms using p2panda. We will build the application with React, Webpack and TypeScript.",source:"@site/docs/tutorials/mushroom-app.md",sourceDirName:"tutorials",slug:"/tutorials/mushroom-app",permalink:"/tutorials/mushroom-app",draft:!1,tags:[],version:"current",frontMatter:{title:"Tutorial: Let's build a mushroom app!"}},p={},m=[{value:"What do I need?",id:"what-do-i-need",level:2},{value:"Start node",id:"start-node",level:2},{value:"Download the application code",id:"download-the-application-code",level:2},{value:"Create a schema",id:"create-a-schema",level:2},{value:"<code>mushroom</code> Schema",id:"mushroom-schema",level:3},{value:"<code>mushroom_finding</code> Schema",id:"mushroom_finding-schema",level:3},{value:"Register schemas",id:"register-schemas",level:3},{value:"Build the application",id:"build-the-application",level:2},{value:"Initialise WebAssembly",id:"initialise-webassembly",level:3},{value:"Generate key pair",id:"generate-key-pair",level:3},{value:"Create operations and entries",id:"create-operations-and-entries",level:3},{value:"Publish data",id:"publish-data",level:3},{value:"Query documents",id:"query-documents",level:3},{value:"Run the application",id:"run-the-application",level:2}],d={toc:m};function h(e){let{components:t,...r}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"In this tutorial we will build an web app for finding and identifying mushrooms using p2panda. We will build the application with ",(0,i.kt)("a",{parentName:"p",href:"https://reactjs.org/"},"React"),", ",(0,i.kt)("a",{parentName:"p",href:"https://webpack.js.org/"},"Webpack")," and ",(0,i.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/"},"TypeScript"),"."),(0,i.kt)("admonition",{title:"This is not a React tutorial",type:"note"},(0,i.kt)("p",{parentName:"admonition"},"This tutorial assumes that you already have experience in using npm, React, Webpack and TypeScript. We want to rather focus on ",(0,i.kt)("em",{parentName:"p"},"using")," the JavaScript library ",(0,i.kt)("inlineCode",{parentName:"p"},"p2panda-js"),". That being said, if you are a beginner, this is also for you as most of the code has already been written!")),(0,i.kt)("p",null,"The idea of the application is inspired by ",(0,i.kt)("a",{parentName:"p",href:"https://plantnet.org"},"PlantNet"),": Users can create entries of different mushrooms to create some sort of community-run encyclopaedia. If you're around in the forest you can take a picture of a spotted mushroom, give it a GPS position and mark it with the mushroom database entry you ",(0,i.kt)("em",{parentName:"p"},"think")," it might be. You can even select multiple mushrooms if you are not sure. The uploaded pictures of all users will show up in some sort of feed."),(0,i.kt)(o.Z,{title:"This is how the app looks like",url:n(5244),mdxType:"ImageFrame"}),(0,i.kt)("p",null,"Of course this is a very simple mushrooming app and we can think of many cool features already now: Like users giving comments on your findings, rating them and even giving suggestions / votes which mushroom it can be - or you could show a world map of all mushroom findings with the help of the GPS positions. Or you can delete findings if they are wrong! All of this is possible with p2panda, you can hack on it if you want after reading this tutorial."),(0,i.kt)("admonition",{title:"Visual identification of mushrooms",type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"All cool polar mushroom animals know that it is not always possible to identify mushrooms based on pictures. There are many other factors as well: The smell, the colour of the spores, the surroundings, time of the year, change of colour after rain and more! Sometimes you even need a microscope to see the spores - to really be sure.")),(0,i.kt)("h2",{id:"what-do-i-need"},"What do I need?"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"NodeJS"),(0,i.kt)("li",{parentName:"ul"},"Rust"),(0,i.kt)("li",{parentName:"ul"},"Editor"),(0,i.kt)("li",{parentName:"ul"},"Terminal"),(0,i.kt)("li",{parentName:"ul"},"Browser")),(0,i.kt)("admonition",{title:"Never worked with Rust before?",type:"info"},(0,i.kt)("p",{parentName:"admonition"},"This tutorial requires you to have a working Rust environment. If you have never worked with Rust before this is no problem! Setting it up is fairly easy and besides using some basic command line commands there is no more Rust knowledge required to make ",(0,i.kt)("inlineCode",{parentName:"p"},"aquadoggo"),", the p2panda node, run on your computer.")),(0,i.kt)("details",null,(0,i.kt)("summary",null,"How do I install Rust?"),(0,i.kt)("p",null,"Make sure you have a working Rust environment installed on your computer before you begin with the tutorial. You can check this by running ",(0,i.kt)("inlineCode",{parentName:"p"},"rustc --version")," in your terminal. This tutorial was written with Rust version ",(0,i.kt)("inlineCode",{parentName:"p"},"1.63.0")," but it will probably also work with other versions."),(0,i.kt)("p",null,"If you don't have Rust installed yet you can follow the steps on the official Rust website: ",(0,i.kt)("a",{parentName:"p",href:"https://www.rust-lang.org/tools/install"},"How to install Rust"),".")),(0,i.kt)("details",null,(0,i.kt)("summary",null,"How do I install NodeJS?"),(0,i.kt)("p",null,"You can check out the official ",(0,i.kt)("a",{parentName:"p",href:"https://nodejs.org/en/download/package-manager/"},"Installing Node.js via package manager")," guidelines here. But we would recommend you installing a NodeJS version manager like ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/nvm-sh/nvm"},"nvm"),", or even better ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/tj/n"},"n"),". We used the NodeJS version ",(0,i.kt)("inlineCode",{parentName:"p"},"18.8.0")," for this tutorial.")),(0,i.kt)("h2",{id:"start-node"},"Start node"),(0,i.kt)("p",null,"Every p2panda client needs a node to talk to, so let's start one! You can follow the ",(0,i.kt)("a",{parentName:"p",href:"/tutorials/aquadoggo"},"Set up a local node")," to learn how to do this in detail, or just run the following steps here:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"# Clone the `aquadoggo` git repository\ngit clone https://github.com/p2panda/aquadoggo.git\n\n# Move into the folder you've just created\ncd aquadoggo\n\n# Compile and start the node with basic logging enabled\nRUST_LOG=aquadoggo=info cargo run\n")),(0,i.kt)("p",null,"Now you have a local node running on port ",(0,i.kt)("inlineCode",{parentName:"p"},"2020"),". You can check if everything is alright by opening your browser and surfing to ",(0,i.kt)("a",{parentName:"p",href:"http://localhost:2020/graphql"},"http://localhost:2020/graphql"),", do you see the GraphQL playground? Super. We will play with it soon!"),(0,i.kt)("h2",{id:"download-the-application-code"},"Download the application code"),(0,i.kt)("p",null,"Since this is not a tutorial about how to write a React web-application, we already prepared most of the source code for you. This is how you can set it up:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"# Clone the `mushroom-app-tutorial` git repository\ngit clone https://github.com/p2panda/mushroom-app-tutorial.git\n\n# Move into the folder you've just created\ncd mushroom-app-tutorial\n\n# Install NodeJS dependencies\nnpm install\n")),(0,i.kt)("p",null,"Let's stay in the ",(0,i.kt)("inlineCode",{parentName:"p"},"mushroom-app-tutorial")," directory from now on, we will look into some code and run a script here."),(0,i.kt)("h2",{id:"create-a-schema"},"Create a schema"),(0,i.kt)("p",null,"We already know what the mushroom app will be capable of, but we need to define as well how the data ",(0,i.kt)("em",{parentName:"p"},"will look like"),". What sort of data do we want to publish, query and visualise in this application?"),(0,i.kt)("p",null,"In p2panda we can create ",(0,i.kt)("em",{parentName:"p"},"schemas")," which will help us to define the shape of the data we need. Nodes will register these schemas and start supporting them. As soon as a node supports a schema you can send that data to it and the node will give you a nice GraphQL API to query it in different ways."),(0,i.kt)("p",null,"For every p2panda application we want to build, we have to define the schemas first we want to use. It could be that there are many even, depending on how complex your program will become."),(0,i.kt)("p",null,"Usually we have to define the schemas only once, as soon as they are deployed on a real node they can be spread across the network: Other nodes will download it automatically when they think it's a good idea to support your schema."),(0,i.kt)("admonition",{title:"Nodes supporting schemas",type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Currently all nodes support all schemas automatically, later we will add features where you can ",(0,i.kt)("em",{parentName:"p"},"whitelist")," schema ids you want to support. This means that nodes will opt-in into supporting different sorts of applications. Some nodes will only support playing chess, some others will only support your mushroom app - maybe there is a node supporting both and more!")),(0,i.kt)("p",null,"During development we might want to create the schema multiple times, because we're deleting the database of our node or we've made some changes to the schema. That's okay!"),(0,i.kt)("admonition",{title:"How do I delete my database?",type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Check out the ",(0,i.kt)("a",{parentName:"p",href:"/tutorials/aquadoggo"},"aquadoggo Tutorial")," to find out.")),(0,i.kt)("p",null,"Enough of all of this theory! How does the data now look like for our mushroom app?"),(0,i.kt)("h3",{id:"mushroom-schema"},(0,i.kt)("inlineCode",{parentName:"h3"},"mushroom")," Schema"),(0,i.kt)("p",null,"We want users to make ",(0,i.kt)("em",{parentName:"p"},"encyclopaedia")," entries about all sorts of mushrooms, similar to a wiki. We keep it simple for now: The ",(0,i.kt)("inlineCode",{parentName:"p"},"mushroom")," schema needs a ",(0,i.kt)("inlineCode",{parentName:"p"},"title"),", a ",(0,i.kt)("inlineCode",{parentName:"p"},"description"),", the ",(0,i.kt)("inlineCode",{parentName:"p"},"latin")," name (because we are real mycologists) and an ",(0,i.kt)("inlineCode",{parentName:"p"},"edible")," flag which indicates if we can eat this mushroom or if it is deadly poisonous."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"title"),": String"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"description"),": String"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"latin"),": String"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"edible"),": Boolean")),(0,i.kt)("h3",{id:"mushroom_finding-schema"},(0,i.kt)("inlineCode",{parentName:"h3"},"mushroom_finding")," Schema"),(0,i.kt)("p",null,"Next to the ",(0,i.kt)("inlineCode",{parentName:"p"},"mushroom")," entries we need the ",(0,i.kt)("inlineCode",{parentName:"p"},"mushroom_finding")," feed of the users. They want to upload a picture (as ",(0,i.kt)("inlineCode",{parentName:"p"},"blob"),"), define a ",(0,i.kt)("inlineCode",{parentName:"p"},"lat")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"lon")," GPS position and mark which ",(0,i.kt)("inlineCode",{parentName:"p"},"mushrooms")," they think it could have been. The users can select one or many mushrooms by simply just referring to the encyclopaedia entries."),(0,i.kt)("p",null,"Relating to the mushroom entries is possible with a ",(0,i.kt)("em",{parentName:"p"},"relation list"),". This is a special sort of field where we can refer to documents of the same or even another schema, simply by mentioning their identifiers."),(0,i.kt)("p",null,"Since p2panda doesn't have any native support for binary data yet (like images or videos), we can make use of a simple trick: We encode the uploaded images as ",(0,i.kt)("a",{parentName:"p",href:"https://stackoverflow.com/questions/6150289/how-can-i-convert-an-image-into-base64-string-using-javascript"},"base64")," and store the image as a string inside the ",(0,i.kt)("inlineCode",{parentName:"p"},"blob")," field."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"blob"),": String"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"lat"),": Float"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"lon"),": Float"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"mushrooms"),": Relation List with ",(0,i.kt)("inlineCode",{parentName:"li"},"mushroom")," documents")),(0,i.kt)("h3",{id:"register-schemas"},"Register schemas"),(0,i.kt)("admonition",{title:"How to create a schema?",type:"info"},(0,i.kt)("p",{parentName:"admonition"},"There is another tutorial showing you ",(0,i.kt)("a",{parentName:"p",href:"/tutorials/send-to-node"},"how you can create schemas")," with the command line tool ",(0,i.kt)("inlineCode",{parentName:"p"},"send-to-node"),". For this tutorial this is not necessary, but if you are wondering what is going on, you should check this out first!")),(0,i.kt)("p",null,"We could create these schemas now manually by sending operations to our node, but we already have that prepared for you. Just run the following command inside the ",(0,i.kt)("inlineCode",{parentName:"p"},"mushroom-app-tutorial")," directory:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"# Create schemas and send them to node\nnpm run schema\n")),(0,i.kt)("p",null,"This will create the two schemas ",(0,i.kt)("inlineCode",{parentName:"p"},"mushroom")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"mushroom_finding")," and register them on your locally running node. You can go to ",(0,i.kt)("a",{parentName:"p",href:"http://localhost:2020/graphql"},"http://localhost:2020/graphql")," to check out the GraphQL playground, there you can now see the newly created schemas in the ",(0,i.kt)("em",{parentName:"p"},"Docs")," tab on the right side!"),(0,i.kt)("admonition",{title:"Huh, I don't see anything?",type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Oh, maybe you should refresh the page then (the playground's auto-refresh can be turned on / off).")),(0,i.kt)("p",null,"You can see that the script gave us some instructions on what to do next:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Next step: Create a file `./schemas.json` and paste this into it:\n{\n  "MUSHROOM_SCHEMA_ID": "mushroom_0020c3accb0b0c8822ecc0309190e23de5f7f6c82f660ce08023a1d74e055a3d7c4d",\n  "FINDINGS_SCHEMA_ID": "mushroom_finding_0020aaabb3edecb2e8b491b0c0cb6d7d175e4db0e9da6003b93de354feb9c52891d0"\n}\n')),(0,i.kt)("p",null,"Your schema ids will look a little bit different since every generated schema is unique! Let's do what the program says and create a ",(0,i.kt)("inlineCode",{parentName:"p"},"schemas.json")," file where we copy this JSON inside. This will tell the program what schemas to look for when doing the GraphQL queries."),(0,i.kt)("h2",{id:"build-the-application"},"Build the application"),(0,i.kt)("p",null,"Designing and creating a schema is a very large part of building an p2panda application. The other part is implementing the interface! Suddenly we're back at ",(0,i.kt)("em",{parentName:"p"},"normal")," web development: Spending long time figuring out how to set up TypeScript, Webpack, some linters like eslint and prettier etc., building React components and views integrating a router and so on. If you are a web developer then this part will be very familiar to you, so let's focus rather on the parts which make it a ",(0,i.kt)("em",{parentName:"p"},"special")," p2panda application."),(0,i.kt)("p",null,"To build something with p2panda in TypeScript or JavaScript we can use the package ",(0,i.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/p2panda-js"},(0,i.kt)("inlineCode",{parentName:"a"},"p2panda-js")),". With it we can do the most important things: 1. Initialise the WebAssembly code 2. Generate a key pair 3. Create p2panda operations and entries 4. Send them to a node 5. Query documents from a node to display them in the app."),(0,i.kt)("p",null,"Let's go through them step by step!"),(0,i.kt)("h3",{id:"initialise-webassembly"},"Initialise WebAssembly"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"p2panda-js")," is actually mainly developed in Rust and compiled as WebAssembly with a thin TypeScript wrapper around it to make it ",(0,i.kt)("em",{parentName:"p"},"feel")," more like a regular TypeScript package. Using WebAssembly is a little bit special and requires you to initialise it before you can use it."),(0,i.kt)("p",null,"In ",(0,i.kt)("inlineCode",{parentName:"p"},"p2panda-js")," we can simply do this like that:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { initWebAssembly } from 'p2panda-js';\nawait initWebAssembly();\n")),(0,i.kt)("admonition",{title:"Where is the WebAssembly code?",type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Good question! We are encoding the WebAssembly code as a base64 string ",(0,i.kt)("em",{parentName:"p"},"inside")," the JavaScript files. This is why it just works like that. If you want to manually load the ",(0,i.kt)("inlineCode",{parentName:"p"},".wasm")," file we have you covered as well, just check out the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/p2panda/p2panda/blob/main/p2panda-js/README.md"},(0,i.kt)("inlineCode",{parentName:"a"},"README.md"))," of the package.")),(0,i.kt)("p",null,"You might already see the problem here though: The ",(0,i.kt)("inlineCode",{parentName:"p"},"initWebAssembly")," function is async! This means that we have to ",(0,i.kt)("em",{parentName:"p"},"wait")," until we can do anything else, like generating a key pair for the user or sending our first operation to the node."),(0,i.kt)("p",null,"Luckily React can help us with some convenient patterns, let's look at the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/p2panda/mushroom-app-tutorial/blob/main/src/components/InitWasm.tsx"},(0,i.kt)("inlineCode",{parentName:"a"},"src/components/InitWasm.tsx"))," file to see how we did it in the mushroom app:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import React, { useEffect, useState } from 'react';\nimport { initWebAssembly } from 'p2panda-js';\n\ntype Props = {\n  children: JSX.Element;\n};\n\nexport const InitWasm: React.FC<Props> = ({ children }) => {\n  const [ready, setReady] = useState(false);\n\n  useEffect(() => {\n    const init = async () => {\n      await initWebAssembly();\n      setReady(true);\n    };\n\n    init();\n  }, []);\n\n  return ready ? children : null;\n};\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"InitWasm")," component will load all ",(0,i.kt)("inlineCode",{parentName:"p"},"children")," components as soon as everything got initialised. If you are concerned about loading times (it should be less than a couple of milliseconds) then you can even add a small spinner here."),(0,i.kt)("p",null,"We wrap the whole application component ",(0,i.kt)("inlineCode",{parentName:"p"},"App")," around ",(0,i.kt)("inlineCode",{parentName:"p"},"InitWasm")," and make sure nothing gets executed before we are ready:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const Root: React.FC = () => {\n  return (\n    <InitWasm>\n      <App />\n    </InitWasm>\n  );\n};\n")),(0,i.kt)("h3",{id:"generate-key-pair"},"Generate key pair"),(0,i.kt)("p",null,"Right after we initialised the WebAssembly we want to make sure that the user gets a key pair. This is required to give the user some sort of identity but also to sign the data the user want's to create."),(0,i.kt)("p",null,"It is quite easy to generate a new key pair with ",(0,i.kt)("inlineCode",{parentName:"p"},"p2panda-js"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { KeyPair } from 'p2panda-js';\nconst keyPair = new KeyPair();\n")),(0,i.kt)("p",null,"But we do not always want to generate a ",(0,i.kt)("em",{parentName:"p"},"new")," key pair every time the user comes back to the website! We should persist the private key using the ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage"},(0,i.kt)("inlineCode",{parentName:"a"},"Window.LocalStorage"))," API:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { KeyPair } from 'p2panda-js';\n\nconst LOCAL_STORAGE_KEY = 'privateKey';\n\nfunction getKeyPair(): KeyPair {\n  // Check if a private key already exists and derive key pair from it if yes\n  const privateKey = window.localStorage.getItem(LOCAL_STORAGE_KEY);\n  if (privateKey) {\n    return new KeyPair(privateKey);\n  }\n\n  // Generate a new key pair otherwise and persist it in localStorage\n  const keyPair = new KeyPair();\n  window.localStorage.setItem(LOCAL_STORAGE_KEY, keyPair.privateKey());\n  return keyPair;\n}\n")),(0,i.kt)("p",null,"Now we can just call ",(0,i.kt)("inlineCode",{parentName:"p"},"getKeyPair")," and we will either receive a new key pair when doing it for the first time or the old one if we're coming back."),(0,i.kt)("p",null,"But how do we now share this information across the whole React application? As a React developer you might know some patterns probably: Prop drilling, Redux, Contexts .. there are many options and it is basically up to you! In the mushroom app we've decided to use the ",(0,i.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/context.html"},"Context")," pattern which gets especially interesting if we have many components. Let's have a look at the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/p2panda/mushroom-app-tutorial/blob/main/src/KeyPairContext.tsx"},(0,i.kt)("inlineCode",{parentName:"a"},"src/KeyPairContext.tsx"))," file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import React, { useMemo } from 'react';\n\ntype Context = {\n  publicKey: string | null;\n  keyPair: KeyPair | null;\n};\n\nexport const KeyPairContext = React.createContext<Context>({\n  publicKey: null,\n  keyPair: null,\n});\n\ntype Props = {\n  children: JSX.Element;\n};\n\nexport const KeyPairProvider: React.FC<Props> = ({ children }) => {\n  const state = useMemo(() => {\n    const keyPair = getKeyPair();\n\n    return {\n      keyPair,\n      publicKey: keyPair.publicKey(),\n    };\n  }, []);\n\n  return (\n    <KeyPairContext.Provider value={state}>{children}</KeyPairContext.Provider>\n  );\n};\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"KeyPairProvider")," helps us to establish the state of the ",(0,i.kt)("inlineCode",{parentName:"p"},"KeyPairContext")," by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"getKeyPair"),". From that point on we populated the state with either our new or old key pair and can consume it by using ",(0,i.kt)("inlineCode",{parentName:"p"},"KeyPairContext.Consumer")," in other components like that:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"<KeyPairContext.Consumer>\n  {({ publicKey }) => {\n    return <p>Hello, {publicKey}!</p>;\n  }}\n</KeyPairContext.Consumer>\n")),(0,i.kt)("p",null,"If you need the ",(0,i.kt)("inlineCode",{parentName:"p"},"keyPair")," already before, you can import the ",(0,i.kt)("inlineCode",{parentName:"p"},"useContext")," hook and access all values like that:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { useContext } from 'react';\nconst { keyPair } = useContext(KeyPairContext);\n")),(0,i.kt)("p",null,"Really handy!"),(0,i.kt)("p",null,"We have to make sure to establish the ",(0,i.kt)("inlineCode",{parentName:"p"},"KeyPairProvider")," in the application as well, we're doing this right at the beginning, next to ",(0,i.kt)("inlineCode",{parentName:"p"},"InitWasm"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const Root: React.FC = () => {\n  return (\n    <InitWasm>\n      <KeyPairProvider>\n        <App />\n      </KeyPairProvider>\n    </InitWasm>\n  );\n};\n")),(0,i.kt)("h3",{id:"create-operations-and-entries"},"Create operations and entries"),(0,i.kt)("p",null,"Operations and entries are the building blocks of p2panda, they ",(0,i.kt)("em",{parentName:"p"},"define")," the contents of everything else: Schemas, Documents, and so on."),(0,i.kt)("admonition",{title:"Entries and operations?",type:"info"},(0,i.kt)("p",{parentName:"admonition"},"If you haven't heard about them yet, you can read the ",(0,i.kt)("em",{parentName:"p"},"learn")," sections on ",(0,i.kt)("a",{parentName:"p",href:"/learn/entries"},"Entries")," and ",(0,i.kt)("a",{parentName:"p",href:"/learn/operations"},"Operations"),".")),(0,i.kt)("p",null,"With ",(0,i.kt)("inlineCode",{parentName:"p"},"p2panda-js")," we can create operations like that:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { KeyPair, signAndEncodeEntry, encodeOperation } from 'p2panda-js';\n\nconst keyPair = new KeyPair();\n\nconst operation = encodeOperation({\n  action: 'create',\n  schemaId: MUSHROOM_SCHEMA_ID,\n  fields: {\n    title: 'Mario Mushroom',\n    latin: 'Marius Fungus',\n    edible: true,\n    description: 'It makes you grow',\n  },\n});\n\nconst entry = signAndEncodeEntry({\n  operation,\n}, keyPair);\n")),(0,i.kt)("p",null,"Yes! We're creating our first ",(0,i.kt)("inlineCode",{parentName:"p"},"mushroom")," document here!"),(0,i.kt)("admonition",{title:"Playing in NodeJS",type:"tip"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"p2panda-js")," also runs in NodeJS and there you don't even need to initialise the WebAssembly! It is fun to play with the API in the interactive NodeJS environment. Just type ",(0,i.kt)("inlineCode",{parentName:"p"},"node")," inside the the ",(0,i.kt)("inlineCode",{parentName:"p"},"mushroom-app-tutorial")," folder, type ",(0,i.kt)("inlineCode",{parentName:"p"},"const p2panda = require('p2panda-js')"),", hit ",(0,i.kt)("inlineCode",{parentName:"p"},"Enter"),", and then you can directly get started, for example by writing ",(0,i.kt)("inlineCode",{parentName:"p"},"const keyPair = new p2panda.KeyPair()"),"! It is fun to create some operations, encode, decode and inspect them directly.")),(0,i.kt)("p",null,"In the example above we are already using the schema id we've created before. Usually you want to keep the schema id in some central place, like in ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/p2panda/mushroom-app-tutorial/blob/main/src/constants.ts"},(0,i.kt)("inlineCode",{parentName:"a"},"src/constants.ts")),". Especially after you officially released your p2panda application it will stay hard-coded like that since schema ids ",(0,i.kt)("em",{parentName:"p"},"never")," change, except of when you migrate to a new schema version of course (but then you also very likely will update your application)."),(0,i.kt)("admonition",{title:"Schema migrations",type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Updating a schema after releasing an application will not break it! Schema ids are ",(0,i.kt)("em",{parentName:"p"},"immutable")," identifiers of the schema for exactly ",(0,i.kt)("em",{parentName:"p"},"that")," version of it. If you introduce a new version, old applications will still point at the previous schema id and the new ones can already support the latest schema."),(0,i.kt)("p",{parentName:"admonition"},"In the future we want to offer ",(0,i.kt)("a",{parentName:"p",href:"https://www.inkandswitch.com/cambria/"},"Lenses")," to automatically support old and new schemas, especially in a p2p system this gets very important after a while.")),(0,i.kt)("p",null,"To sign and encode a new entry we usually need to know what the sequence number, log id, backlink- and skiplink hash is. This information we get from our node and we can ask about it by doing a ",(0,i.kt)("inlineCode",{parentName:"p"},"nextArgs")," GraphQL query!"),(0,i.kt)("p",null,"Let's set up a GraphQL client first:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { GraphQLClient, gql } from 'graphql-request';\nconst client = new GraphQLClient('http://localhost:2020/graphql');\n")),(0,i.kt)("admonition",{title:"GraphQL libraries",type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"In this tutorial we're using ",(0,i.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/graphql-request"},(0,i.kt)("inlineCode",{parentName:"a"},"graphql-request"))," as a GraphQL client. We like this one because it is very simple and lightweight, but there are many others as well, for example ",(0,i.kt)("a",{parentName:"p",href:"https://www.apollographql.com/"},"Apollo"),".")),(0,i.kt)("p",null,"Now we can make the ",(0,i.kt)("inlineCode",{parentName:"p"},"nextArgs")," query to receive the required arguments:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"type NextArgs = {\n  logId: string;\n  seqNum: string;\n  backlink?: string;\n  skiplink?: string;\n};\n\nasync function nextArgs(publicKey: string, viewId?: string): Promise<NextArgs> {\n  const query = gql`\n    query NextArgs($publicKey: String!, $viewId: String) {\n      nextArgs(publicKey: $publicKey, viewId: $viewId) {\n        logId\n        seqNum\n        backlink\n        skiplink\n      }\n    }\n  `;\n\n  const result = await client.request(query, {\n    publicKey,\n    viewId,\n  });\n\n  return result.nextArgs;\n}\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("mdxAdmonitionTitle",{parentName:"admonition"},"Why is ",(0,i.kt)("inlineCode",{parentName:"mdxAdmonitionTitle"},"seqNum")," and ",(0,i.kt)("inlineCode",{parentName:"mdxAdmonitionTitle"},"logId")," a string?"),(0,i.kt)("p",{parentName:"admonition"},"p2panda supports ",(0,i.kt)("inlineCode",{parentName:"p"},"u64")," integers for sequence numbers and log id but JavaScript only supports up to ",(0,i.kt)("a",{parentName:"p",href:"https://262.ecma-international.org/6.0/#sec-number.max_safe_integer"},"53bit")," to encode numbers. There is ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt/BigInt"},(0,i.kt)("inlineCode",{parentName:"a"},"BigInt"))," as well but we can't use it inside of JSON (which is the format of the GraphQL response). This is why we represent numbers in JavaScript as strings! They can be of any size then and latest when they arrive in the WebAssembly code they will be checked and correctly converted into ",(0,i.kt)("inlineCode",{parentName:"p"},"u64"),".")),(0,i.kt)("p",null,"Whenever we create a new ",(0,i.kt)("inlineCode",{parentName:"p"},"mushroom")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"mushroom_finding")," document we just have to pass in the ",(0,i.kt)("inlineCode",{parentName:"p"},"publicKey")," to the ",(0,i.kt)("inlineCode",{parentName:"p"},"nextArgs")," method to receive everything we need. With all of this and our key pair we can now encode the operation and finally sign the entry:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"type Mushroom = {\n  title: string;\n  description: string;\n  latin: string;\n  edible: boolean;\n};\n\nasync function createMushroom(\n  keyPair: KeyPair,\n  values: Mushroom,\n): Promise<void> {\n  const args = await nextArgs(keyPair.publicKey());\n\n  const operation = encodeOperation({\n    schemaId: MUSHROOM_SCHEMA_ID,\n    fields: {\n      ...values,\n    },\n  });\n\n  const entry = signAndEncodeEntry(\n    {\n      ...args,\n      payload: operation,\n    },\n    keyPair,\n  );\n\n  await publish(entry, operation);\n}\n")),(0,i.kt)("h3",{id:"publish-data"},"Publish data"),(0,i.kt)("p",null,"To send the entry and operation now to the node we make use of the ",(0,i.kt)("inlineCode",{parentName:"p"},"publish")," GraphQL mutation:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"export async function publish(\n  entry: string,\n  operation: string,\n): Promise<NextArgs> {\n  const query = gql`\n    mutation Publish($entry: String!, $operation: String!) {\n      publish(entry: $entry, operation: $operation) {\n        logId\n        seqNum\n        backlink\n        skiplink\n      }\n    }\n  `;\n\n  const result = await client.request(query, {\n    entry,\n    operation,\n  });\n\n  return result.publish;\n}\n")),(0,i.kt)("p",null,"This is it! We can now create ",(0,i.kt)("inlineCode",{parentName:"p"},"mushroom")," documents."),(0,i.kt)("p",null,"If we're updating or deleting a document we need to specify ",(0,i.kt)("em",{parentName:"p"},"what")," document we want to apply these changes on. This we do by passing in the ",(0,i.kt)("inlineCode",{parentName:"p"},"viewId"),". The ",(0,i.kt)("inlineCode",{parentName:"p"},"viewId")," you can get from the GraphQL API, whenever you query for the documents you want to update or delete."),(0,i.kt)("p",null,"All of this you find in the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/p2panda/mushroom-app-tutorial/blob/main/src/requests.ts"},(0,i.kt)("inlineCode",{parentName:"a"},"src/requests.ts"))," file, there you will find other queries as well, for example to create ",(0,i.kt)("inlineCode",{parentName:"p"},"mushroom_finding")," documents."),(0,i.kt)("h3",{id:"query-documents"},"Query documents"),(0,i.kt)("p",null,"After creating the ",(0,i.kt)("inlineCode",{parentName:"p"},"mushroom")," documents we want to query them as well. We can do this like that:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"type Meta = {\n  viewId: string;\n  documentId: string;\n};\n\ntype Mushroom = {\n  description: string;\n  edible: boolean;\n  latin: string;\n  title: string;\n};\n\ntype MushroomResponse = {\n  meta: Meta;\n  fields: Mushroom;\n};\n\nasync function getAllMushrooms(): Promise<MushroomResponse[]> {\n  const query = gql`{\n    mushrooms: all_${MUSHROOM_SCHEMA_ID} {\n      documents {\n        meta {\n          documentId\n          viewId\n        }\n        fields {\n          description\n          edible\n          latin\n          title\n        }\n      }\n    }\n  }`;\n\n  const { mushrooms } = await client.request(query);\n  return mushrooms.documents;\n}\n")),(0,i.kt)("p",null,"If you prepend the schema id in the query with ",(0,i.kt)("inlineCode",{parentName:"p"},"all_")," you receive a collection of ",(0,i.kt)("em",{parentName:"p"},"all")," ",(0,i.kt)("inlineCode",{parentName:"p"},"mushroom")," documents."),(0,i.kt)("admonition",{title:"Pagination, filters and sorting",type:"info"},(0,i.kt)("p",{parentName:"admonition"},"The ",(0,i.kt)("a",{parentName:"p",href:"https://p2panda.org/specification/APIs/queries"},"specification")," already mentions pagination, filters and sorting but we have not implemented it yet, it will come soon!")),(0,i.kt)("p",null,"See how we can also get some ",(0,i.kt)("inlineCode",{parentName:"p"},"meta")," fields from the regarding mushroom documents? We can get the ",(0,i.kt)("inlineCode",{parentName:"p"},"documentId")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"viewId")," for each entry, this helps us to update or delete the data as mentioned earlier."),(0,i.kt)("p",null,"If you want to only load one mushroom you can write something like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'async function getMushroom(\n  documentId: string,\n): Promise<MushroomResponse> {\n  const query = gql`{\n    mushroom: ${MUSHROOM_SCHEMA_ID}(id: "${documentId}") {\n      meta {\n        documentId\n        viewId\n      }\n      fields {\n        description\n        edible\n        latin\n        title\n      }\n    }\n  }`;\n\n  const { mushroom } = await client.request(query);\n  return mushroom;\n}\n')),(0,i.kt)("p",null,"Now we talked almost about everything you need to build an p2panda application with React. You can dive a little bit more inside of the source code to see some details, but we should have covered the most important parts concerning p2panda!"),(0,i.kt)("h2",{id:"run-the-application"},"Run the application"),(0,i.kt)("p",null,"Finally, let's use the mushroom app now!"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"npm start\n")),(0,i.kt)("p",null,"This will run the web application under ",(0,i.kt)("a",{parentName:"p",href:"http://localhost:8080"},"http://localhost:8080"),". You can open it in your browser and start playing with it. If you're curious you can also check the GraphQL playground of the ",(0,i.kt)("inlineCode",{parentName:"p"},"aquadoggo")," and make some queries there to compare!"),(0,i.kt)("admonition",{title:"High-Level frameworks",type:"info"},(0,i.kt)("p",{parentName:"admonition"},"For this tutorial we have been using ",(0,i.kt)("inlineCode",{parentName:"p"},"p2panda-js")," which is a fairly ",(0,i.kt)("em",{parentName:"p"},"low-level")," API. In the future we want to offer more ",(0,i.kt)("em",{parentName:"p"},"high-level")," frameworks like ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/p2panda/shirokuma"},(0,i.kt)("inlineCode",{parentName:"a"},"shirokuma"))," which will take care of even more things for us, like internally handling the GraphQL queries, caching arguments to create entries and persisting key pairs automatically for us.")))}h.isMDXComponent=!0}}]);